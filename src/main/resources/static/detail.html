<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>博客详情页</title>

    <script src="js/jquery.min.js"></script>
    <script src="Semantic/semantic.min.js"></script>
    <link href="Semantic/semantic.min.css" rel="stylesheet">




    <link href="lib/typo/typo.css" rel="stylesheet">


    <script src="lib/prism/prism.js"></script>
    <link href="lib/prism/prism.css" rel="stylesheet">


    <link href="lib/animate.min.css" rel="stylesheet">


    <link href="css/common.css" rel="stylesheet">

    <script src="js/detail.js"></script>
    <link href="css/detail.css" rel="stylesheet">


</head>
<body>

<div  class="ui attached segment animated slideInDown">


    <div class="ui breadcrumb black">
        <a href="index.html">blog</a>
        <div class="divider"> / </div>
        <a class="section active">详情</a>

    </div>
</div>
<!-- 中间start -->

<div id="center" class="ui container stackable">

    <div class="ui grid stackable mobile reversed">

        <div class="ui four wide column stackable bordered">


            <div class="  ui list stackable animated slideInDown" id="info">

                <div class="sixteen ui wide column card stackable ">
                    <div class="ui list stackable sixteen">
                        <div class="item ">
                            <img class="ui medium circular image" id="icon" src="img/photo.jpg">
                        </div>
                        <div class="item ">Mine_希冀</div>
                        <div class="item ">但行好事 莫问前程</div>
                        <div class="item">

                            <i class="paper plane icon"></i> &nbsp;广东

                        </div>
                    </div>
                    <br>
                </div>
            </div>


            <!--<div class="ui skyscraper test ad" data-text="超高"></div>-->


        </div>

        <div class="twelve wide column stackable   animated slideInDown" id="blogBody">

            <div class="ui top attached segment center aligned">
                <div class="ui one column grid stackable">
                    <div class="column">
                        <h3 class="ui teal header" >title</h3>
                    </div>
                </div>

                <div class="ui  divider">

                </div>

                <div class="ui mini horizontal link list stackable">

                    <div class="item">
                        <span class="original">原创</span>
                    </div>
                    <div class="item">
                        <i class="clock outline icon"></i><span>2020-03-21</span>
                    </div>
                    <div class="item">
                        <i class="eye icon"></i> <span>0</span>
                    </div>

                    <div class="item">
                        <i class="comment alternate icon"></i> <span>0</span>
                    </div>
                </div>

            </div>


            <div class="ui attached segment center aligned">
                <div class="ui five wide column">
                    <a href="">
                        <img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584886233933&amp;di=984c5adffbeee9133453b53cdfaa912f&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F4ec2d5628535e5dd24d1534b74c6a7efcf1b62a1.jpg" alt="" class="ui rounded image">
                    </a>
                </div>
            </div>

            <div class="ui attached segment typo typo-selection">
                <h2 id="前言">前言</h2>
                <p>如文章题目所示，本文只对JDK1.8版本的HashMap部分源码进行阅读，请不要与JDK1.7及之前版本的HashMap混淆。</p>
                <h2 id="hashmap数据结构">HashMap数据结构</h2>
                <p>相信大部分Java程序员都知道HashMap的数据结构，即数组+链表（单向）+红黑树。为什么是这样的数据结构呢？下面是我自己对该数据结构的理解：</p>
                <p>首先，HashMap存储的数据格式是key-value格式，那么，很容易就可以想到：创建一个内部类，包含key和value两个字段，再使用数组将其存储起来，就能满足上述要求，即<strong>数组是必需的</strong>。
                    其次，为什么不能只用数组？众所周知，HashMap的key值不能重复，如果只用数组，那么每次在调用put方法插入新元素的时候，都需要遍历已存在的每一个元素去比较key值是否重复，这样一来，随着数据的增加，性能将会直线下降。<br>
                    因此，为了解决上述问题，我们需要<strong>将key值和数组的下标建立某种联系，以便于我们可以通过key值直接找到对应元素。</strong><br>
                    那么，如何建立联系？我们知道，HashMap的key值可以是<strong>任意类型的实例对象（不可变对象），甚至可以包括null</strong>，而数组的下标是<strong>数字</strong>，要想将这两者建立联系，我们可以想到的算法就是散列算法，即<strong>hash算法</strong>:把任意长度的输入通过散列算法变换成固定长度的输出。<br>
                    此时，我们解决了将key值和数组下标建立联系的问题。但是，金无足赤，人无完人，hash算法也不是完美的算法，<strong>即使输入不同，它的计算结果仍然有可能是相同的</strong>，即<strong>hash冲突</strong>。那么，问题来了，如果不同key值在使用hash算法计算数组下标时，发生了hash冲突，即数组下标一致，此时，既不能覆盖已存在的元素（key值不同），又不能舍弃新元素，该怎么办呢？显然，只用数组已经不能满足我们的要求了，于是，我们加入了链表。<br>
                    然后，链表为何是单向的？我们可以从单向链表和双向链表的优劣势进行分析：单向链表只维护了下一个节点的地址，占用存储空间小，增删节点效率高，而双向链表的优点是可以双向查找节点，相比较而言，HashMap使用单向链表的好处要大于使用双向链表。<br>
                    到现在为止，HashMap的要求和特性基本都满足了，那么为什么还要使用红黑树呢？其实，在JDK1.8之前，HashMap确实只用了数组+链表。但是，百尺竿头，更进一步，JDK从未停止优化自己的脚步。试想一下，随着数据的增加，hash冲突的出现越来越多，导致链表越来越长，此时，无论是查询还是增删操作的效率都会变低。因此<strong>JDK1.8做了优化，将超出一定长度的链表转为红黑树</strong>，以增加HashMap的读写性能。</p>
                <h2 id="源码阅读">源码阅读</h2>
                <p>接下来就是重头戏了，说实话，HashMap的源码确实看了很久，到目前为止，仍有一部分还没悟透，但基本流程还算摸了个大概，接下来就跟大家分享我自己的学习成果。
                    上代码：</p>
                <pre class=" language-java"><code class=" language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                <p>这两行代码，基本上把HashMap的关键操作都涉及到了，下面就一行一行分析。
                    第一行代码，创建HashMap实例，点进去看源码的构造方法如下：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token comment" spellcheck="true">/**
 * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
 * (16) and the default load factor (0.75).
 */</span>
<span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>是不是很奇怪，HashMap的构造方法里竟然没有对数组进行初始化？相反，只是对loadFactor这个成员变量赋给了一个默认值。再看注解：</p>
                <blockquote>
                    <p>构建一个空的HashMap,并使用默认的初始容量（16）和默认负载因子（0.75）
                        所有其他属性都取默认值</p>
                </blockquote>
                <p>看完这个构造方法，瞬间头大。初始容量还能理解，就是<strong>数组的初始长度是16</strong>，负载因子是啥？其他属性还有什么？数组在哪里初始化？先别急，我们来看第二行代码，给map添加新元素，即调用put方法，点进去看源码如下（注释太占篇幅，此处省略，后面需要解释的会贴出来）：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>此时，我们看到了一个想看到的东西：<strong>hash(key)</strong>，这就是我们提到的，建立key值与数组下标的联系的步骤之一。点进去看源码如下：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>从这里我们可以看到，此方法返回的hash值是由，<strong>key的hashCode值</strong>和<strong>自身右移16位</strong>后做<strong>异或</strong>操作所得。那么，为什么不直接用hashCode值呢？只能说算法大牛的思维，我们这些常人是理解不了的。直接使用hashCode值，仍是有很大概率发生hash冲突的，而代码中的“骚操作”增加了扰动，可以有效降低冲突概率。
                    回到put方法，发现其调用了putVal方法，点进去看源码如下：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>
            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>代码虽然很长，但不难发现，其中有很多if-else，我们一个一个来分析。<br>
                    首先，参数列表中前三个都是我们提到的：hash值，key，value，后两个不影响源码阅读，暂且略过。<br>
                    然后，方法的第一行声明了几个变量，其中没见过的就是Node类型，点进去看其属性如下：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>
    V value<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>其中，hash、key、value我们都知道了，而Node类型只有一个next属性，这就验证了我们之前说过的，<strong>HashMap使用的是单向链表</strong>。<br>
                    再回到putVal方法，第一行声明变量之后，紧接着就是一个if：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
                <p>首先，我们看到了一个没见过的变量名：table。tab是第一行声明的，那table是什么？我们找到它声明的地方：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
</code></pre>
                <p>原来，table就是我们一直在找的数组，它是成员变量，默认是null。<br>
                    然后，我们理解一下if的判断和执行语句：<strong>当数组为null，或者数组长度为0时，调用resize方法</strong>，并把返回值赋值给tab变量，把返回值的长度赋值给n。此时，putVal方法暂停，进入resize方法，点进去看源码如下：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
                 oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>又是一段贼长的代码，没关系，我们只看我们用到的。<br>
                    首先，第一行代码是将table赋值给局部变量oldTab，table成员变量我们已经见过了，因为我们是新建的HashMap对象，所以此时table变量还是null，即oldTab也是null。<br>
                    然后，第二行代码是将oldTab的长度赋值给局部变量oldCap，此时oldTab为null，那么oldCap为0。<br>
                    再然后，第三行代码将threshold赋值给局部变量oldThr，此时出现了一个新的成员变量：threshold，找到它声明的地方：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token comment" spellcheck="true">/**
 * The next size value at which to resize (capacity * load factor).
 *
 * @serial
 */</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
</code></pre>
                <p>我们可以从注释里看到：下一个进行扩容操作的长度值（容量 * 负载因子）。关于这部分内容，会在后面进行解释，此处先行略过，继续阅读resize方法。此时threshold并没有初始化，即默认为0，则oldThr也为0。<br>
                    第四行代码就很简单了，声明两个新的局部变量：newCap，newThr，并初始化为0。<br>
                    然后进入if判断，根据前面的描述，此时oldCap和oldThr都是0，因此前面两个if都不成立，直接跳到else语句：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">else</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>
    newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
    newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>newCap赋值为初始容量（16），newThr赋值为初始容量（16） * 初始负载因子（0.75），即12。同样的，这个我们后面再解释。<br>
                    紧接着，又是一个if语句，而此时newThr=12，条件不成立，略过。继续往下看：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
</code></pre>
                <p>终于！它出现了！我们一直在寻找的数组初始化操作终于出现了！！！原来，<strong>HashMap的数组并不是在创建对象时初始化的，而是在resize方法里初始化的。</strong><br>
                    然后，就将初始化的数组赋值给成员变量table。再然后就又是一个if语句，通过之前的记录，oldTab=null，条件不成立，略过。最后将初始化的数组返回。<br>
                    到此为止，resize方法执行完成，我们再回到putVal方法。还记得执行到哪一步了吗？没错，就是putVal方法的第一个if语句。
                    此时，局部变量tab为初始化后的数组，局部变量n为16。<br>
                    然后我们来到了putVal方法的第二个if语句：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                <p>重点来了！建立key值与数组下标的联系的步骤之二------<strong>i = (n - 1) &amp; hash</strong>。之前resize方法返回的数组长度是16，所以我们需要计算的下标范围是0~15。<br>
                    此时，n=16，n-1=15，转换为二进制数就是：1111。&amp;是位与运算符，即按位相与，而我们都知道，不管是0还是1，跟1相与都是其本身，所以此处运算的最后结果就是舍弃hash值的高位，只保留hash值的低4位，而4位二进制数的范围就是0~15。是不是很神奇？<br>
                    试想一下，如果让我们自己来计算，最容易想到的办法就是取模运算，即hash%16。为什么HashMap要使用位运算呢？两个字：效率。<strong>位运算是运算中最高效的。<strong>所以</strong>看源码不仅仅是为了了解其原理，更是为了学习如何写出优秀的代码。</strong><br>
                    回到代码，下标计算完成后，将下标赋值给局部变量i，再将数组中i位置的元素赋值给p，然后判断p是否为空。显然，此时的数组刚刚初始化，里面并没有任何元素，所以条件成立，调用newNode方法创建一个新的Node实例（方法内部就是一个new Node，因此源码就不再展示），然后插入到数组的i位置。<br>
                    if语句既然成立，那么else自然不成立，略过。此时，只剩最后5行代码了：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token operator">++</span>modCount<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
    <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> null<span class="token punctuation">;</span>
</code></pre>
                <p>其中，第一行、第四行本文不涉及，感兴趣的可以自行研究。最后一行return语句，自然也没什么可说的。<br>
                    我们只看第二行和第三行，此时，又出现一个成员变量：size。其实，猜也能猜到，size就是当前HashMap实例中所存储的元素的总个数。让我们找到声明它的位置：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token comment" spellcheck="true">/**
 * The number of key-value mappings contained in this map.
 */</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
</code></pre>
                <p>看到注释就知道我们的猜测是正确的，而if语句的意思就是：当已存储的元素个数大于threshold时，调用resize方法（此处与threshold统一放到后面讲）。然后整个putVal方法结束，返回null。<br>
                    于是乎，我们走完了一次put操作，可以发现，其实源码并没有那么难啃，正所谓世上无难事，只要肯放弃……呸！只怕有心人。当然了，在上述过程中，我们略过了很多if语句，所以会显得比较简单。但回过头来想，if语句无非就是多个分支，我们已经走完了一个分支，剩下的分支只要花点时间就可以了。本文限于篇幅，就不再一步一步串源码流程了，后面的就直接表述HashMap的一些特点，中间会插入部分相关源码。</p>
                <h2 id="hashmap特点">HashMap特点</h2>
                <h3 id="扩容机制">扩容机制</h3>
                <h4 id="扩容阈值">扩容阈值</h4>
                <p>在源码阅读环节，我们接触到了一个成员变量：threshold。通过它的注释，我们知道了它的计算方式是：capacity x load factor，即容量 x 负载因子。而负载因子我们也知道，它的默认值是0.75。<br>
                    看到这里，应该不难理解了。HashMap的数组初始化长度是16，那么随着存储元素的增加，数组必然面临着扩容问题，而此时我们就需要一个扩容阈值。而阈值的计算方法就是16 * 0.75 = 12，即存储元素超过12个，就会扩容。<br>
                    那么为什么是0.75呢？这是通过大量实验统计得出来的，如果过小，比如0.5，那么当存放的元素超过一半时就进行扩容，会造成资源的浪费；如果过大，比如1，那么当元素满的时候才进行扩容，会使get和put操作的碰撞几率增加。</p>
                <h4 id="扩容长度">扩容长度</h4>
                <p>扩容的阈值我们知道了，那么HashMap一次扩容操作会扩大多少容量呢？看源码（resize方法）：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
     oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>
</code></pre>
                <p>可以看到，源码中使用了左移运算，即乘以2。也就是说，<strong>HashMap每次扩容都是两倍扩容</strong>。这是为什么呢？<br>
                    小伙伴们应该还记得数组下标的计算方法吧：i = (n - 1) &amp; hash。之前我们说过，数组下标的计算要尽可能不发生hash冲突，即结果尽量不重复。而计算中又使用了位与运算，那么，<strong>为了尽可能使结果不重复，我们应该保证"n-1"转换为二进制后，每一位都是1</strong>。只有这样，才能保留hash值的特殊性。如果n-1的某一位是0，那么无论hash值在这一位是什么，该位的最终结果都是0，显然，这样就会增加hash冲突的概率。<br>
                    那么，怎么保证"n-1"转换为二进制后，每一位都是1？很简单，只要n值是2的幂次就可以了，所以HashMap每次扩容都是乘以2。<br>
                    此时有人说了：那如果把初始容量改成非2的幂次，以后扩容虽说是2倍，但也无法保证刚才说的条件啊？这一点我们能想到，HashMap的开发人员当然也想到了。我们去看HashMap构造方法的源码，其中能传入初始容量参数的有两个：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token comment" spellcheck="true">/**
 * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
 * capacity and load factor.
 *
 * @param  initialCapacity the initial capacity
 * @param  loadFactor      the load factor
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */</span>
<span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>
                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
        initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>
                                           loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
 * capacity and the default load factor (0.75).
 *
 * @param  initialCapacity the initial capacity.
 * @throws IllegalArgumentException if the initial capacity is negative.
 */</span>
<span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>可以看到，第二个构造方法调用了第一个，所以我们只关心第一个即可。<br>
                    前面的if语句无非是判断参数的合法性，即不能是负数。<br>
                    然后我们就看到了一个方法---tableSizeFor(initialCapacity)，点进去看源码：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token comment" spellcheck="true">/**
 * Returns a power of two size for the given target capacity.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>看到这个代码，头又大了~别急，千里之行，始于足下，让我们假设一个值，然后一步一步走下去，看看这个方法到底做了什么。<br>
                    假设，cap=10，则n=9；然后，我们看到一个运算符"|="，有人说“这个运算符没见过啊”，那"+="见过吗？没错，道理是一样的。"n |= n &gt;&gt;&gt; 1"就等于"n = n | n &gt;&gt;&gt; 1"，又是位或运算（HashMap是多喜欢位运算~），下面就一步一步进行计算：<br>
                    第一次计算：n=9，转成二进制是1001，右移一位就是0100，这两个做或运算的结果就是1101；<br>
                    第二次计算：n=1101，右移两位就是0011，或运算结果就是1111；<br>
                    第三次计算：n=1111，右移四位就是0000，或运算结果还是1111；<br>
                    第四次计算：n=1111，右移八位就是0000，或运算结果还是1111；<br>
                    第五次计算：n=1111，右移八位就是0000，或运算结果还是1111；<br>
                    最后，n既不小于0，也不大于最大容量，所以返回n+1，就是16，也就是默认的初始容量。<br>
                    又一次见证了奇迹！！！其实，如果耐心进行多次计算的话，会发现，这个方法的目的就是<strong>向上找到最接近参数值的2次幂数</strong>。这样一来，不管你传入的容量是多少，HashMap都会自动转成2次幂数，来减少hash冲突。<br>
                    现在，我们知道了一次扩容的长度，那么数组最大会扩容到多大呢？看源码（resize方法）：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>常量值MAXIMUM_CAPACITY（最大容量）是2^30，此段代码的意思是：当数组长度大于等于该常量时，扩容阈值就被设置成int类型的最大值，即2^31-1，然后就直接返回旧数组。所以HashMap的数组并不是无限扩容，数组的最大容量就是2^30。<br>
                    那么，如果此时再向HashMap中插入新元素会怎么样呢？以我目前对源码的理解，即使数组达到最大容量，不再扩容，HashMap依然可以插入新元素。只不过到最后，数组会被占满，所有链表都会变成红黑树，每次插入都会发生hash冲突。如果这里我的理解有误，还望小伙伴们留言指正呦~~</p>
                <h4 id="扩容时的重排算法">扩容时的重排算法</h4>
                <p>这里的重排指的是：如果数组中存在链表或者红黑树，当数组扩容时，链表和红黑树就会进行重排。目的当然是优化性能了，毕竟链表和红黑树越少，HashMap的读写性能就会越好。<br>
                    这里为什么要单独说一下重排算法呢？因为HashMapde的这个算法设计的非常巧妙，看源码（resize方法）：</p>
                <pre class=" language-java"><code class=" language-java">Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
            loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
        loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
            hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
        hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>这是链表重排的代码，红黑树重排的代码在split方法中，基本上是一样的，所以我们以链表为例。<br>
                    主要看第一个if语句中条件："(e.hash &amp; oldCap) == 0"，这里就要联系上一小节的内容了，为了理解起来比较简单，下面举例说明：<br>
                    假设此时数组长度是16，那么通过上一小节我们知道了，下标是hash值和1111做与运算，当扩容操作发生时，新的数组长度变成2倍，也就是32，这时如果要计算下标，那么就是hash值和11111做与运算。注意这里！！仔细观察可以发现，扩容前和扩容后的与运算的区别仅仅只是高位（第5位）的1，低4位不变。这样一来，我们只需要关心hash值在高位（第5位）上的值是0还是1就行了，如果是0，那么扩容前后的下标不变；如果是1，那么扩容后的下标比扩容前多了16（第5位的1转成十进制就是16）。<br>
                    然后，我们回过头再看代码：(e.hash &amp; oldCap) == 0。oldCap就是扩容前的数组长度，转成二进制刚好就是扩容后高位上的1。hash值和oldCap做与运算，留下的就是hash值在高位的值。如果是0，该元素的数组下标不变；如果是1，该元素移动到“原始下标+oldCap”的位置。
                    这样的计算，既不需要像JDK1.7的实现那样重新计算hash，而且同时，由于扩容后的高位是0还是1可以认为是随机的，因此，扩容的过程就会均匀地把之前的冲突的节点分散到新的数组节点。<br>
                    另外，<strong>在JDK1.7中，旧链表迁移新链表的过程是倒置追加的，这样的模式在多线程下就会出现死循环问题</strong>（这一点的原理已经被分析的透透的了，度娘一搜一大把，所以本文就不再赘述了）。而我们看到JDK1.8的实现，是没有倒置追加的，所以1.8就没有上述问题。</p>
                <h3 id="链表与红黑树">链表与红黑树</h3>
                <p>在文章开头，我解释了为什么要使用链表和红黑树。使用链表是为了应对hash冲突，使用红黑树是为了增加读写性能。<br>
                    那么链表和红黑树之间是如何转换的呢？<br>
                    我们先来看链表是如何转成红黑树的，看源码（putVal方法）：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>
            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>在链表插入新节点时，会判断当前链表的长度是否达到了TREEIFY_THRESHOLD常量值----8（代码中为什么要-1？因为binCount是从0开始循环的），如果是，则调用treeifyBin方法<strong>意图</strong>将链表转成红黑树。注意！这里是意图。我们看treeifyBin方法的源码：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token comment" spellcheck="true">/**
 * Replaces all linked nodes in bin at index for given hash unless
 * table is too small, in which case resizes instead.
 */</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;</span> e<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>注意第一if语句：当数组为null或者数组长度小MIN_TREEIFY_CAPACITY常量值---64，直接调用resize方法，即进行扩容重排。<br>
                    现在我们知道了，<strong>链表转成红黑树是有两个条件的：1.链表长度大于等于8；2.数组长度大于64。</strong><br>
                    这样的话，那红黑树转成链表的条件是不是刚好相反呢？并不是，看源码（split方法）：</p>
                <pre class=" language-java"><code class=" language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>loHead <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>index <span class="token operator">+</span> bit<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                <p>这里为什么有两个if？因为split方法是在resize方法里调用的，也就是说<strong>红黑树转链表的时机发生在扩容阶段</strong>。这两个if是扩容之后，原来的红黑树被分裂成了两个子树。<br>
                    再看源码，当红黑树的节点个数小于等于UNTREEIFY_THRESHOLD常量值---6，就会调用untreeify方法将红黑树转成链表，而untreeify方法里没有新的限制条件，所以，<strong>红黑树转成链表也是有两个条件的：1.发生扩容操作；2.扩容之后红黑树的节点数小于等于6。</strong></p>
                <h2 id="总结">总结</h2>
                <p>按照文章顺序梳理一下HashMap的知识点：<br>
                    1.HashMap的数据结构是数组+单向链表+红黑树；<br>
                    2.HashMap的数组默认长度是16，负载因子默认是0.75；<br>
                    3.key值的hash计算："key的hashCode"和"hashCode右移16位"的异或；<br>
                    4.HashMap数组的初始化并不是在构造方法里，而是在resize方法里；<br>
                    5.HashMap使用了大量的位运算；<br>
                    6.HashMap的元素个数超过阈值就会进行扩容，而阈值的计算是当前长度*负载因子；<br>
                    7.HashMap每次扩容都是之前的2倍，最大值是2^30；<br>
                    8.HashMap虽然支持传入数组长度参数，但其内部会自动将数组长度转成2的幂次数；<br>
                    9.在扩容操作中，JDK1.8相比于1.7的优化：重排时，不再重新计算hash值；链表迁移不再使用倒置追加，避免了多线程下的死循环问题；<br>
                    10.HashMap中链表转成红黑树的条件：1.链表长度大于等于8；2.数组长度大于64；<br>
                    11.HashMap中红黑树转成链表的条件：1.发生扩容操作；2.扩容之后红黑树的节点数小于等于6；</p>
                <p>以上就是本人对HashMap源码的学习心得，有不理解或者错误的地方，欢迎小伙伴留言探讨~~~~</p>



            </div>


            <div class="ui attached positive segment left  ">


                <a href="/types/5" target="_blank" class="ui blue basic label">
                    <i class=" tags icon left"></i>
                    java
                </a>
                <a href="/types/5" target="_blank" class="ui blue basic label">
                    <i class=" tags icon left"></i>
                    spring
                </a>
            </div>

            <div class="ui attached segment center aligned">



                <div class="ui attached positive message">
                    <div class="ui middle aligned grid">
                        <div class="eleven wide column">
                            <ui class="list">
                                <li>作者：<span>XXX</span>
                                </li>
                                <li>发表时间：<span>2020-04-17 02:08</span>
                                </li>
                                <li>版权声明：本文为博主的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
                                    原文链接：https://xxxx.com</li>
                            </ui>
                        </div>

                    </div>
                </div>


            </div>

            <div class="ui attached segment center aligned" id="PlayTour">

                <div  class=" payShow ui label flowing popup transition " >
                    <div class="ui images">

                        <div class="image">
                            <img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584886233933&amp;di=984c5adffbeee9133453b53cdfaa912f&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F4ec2d5628535e5dd24d1534b74c6a7efcf1b62a1.jpg" alt="" >
                        </div>
                        <div class="image">
                            <img  src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584886233933&amp;di=984c5adffbeee9133453b53cdfaa912f&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F4ec2d5628535e5dd24d1534b74c6a7efcf1b62a1.jpg" alt="" >
                        </div>

                    </div>
                </div>


                <button class="ui basic button orange PlayTourBtn"  >
                    赞赏
                </button>
            </div>

        </div>

    </div>


    <div class="ui four wide column stackable right">
        &nbsp;
    </div>
    <div class="ui twelve wide column stackable right">


        <div class="ui bottom attached segment">
            <div id="comment-container" class="ui teal segment"><div>
                <h3 class="ui teal header center aligned">评论区</h3>


                <div class="ui threaded comments" style="max-width: 100%;">
                    <div class="comment">
                        <a class="avatar">
                            <img src="img/photo.jpg">
                        </a>
                        <div class="content">
                            <a class="author">
                                <span>Dylan</span>

                            </a>
                            <div class="metadata">
                                <span class="date">2020-04-09 11:47</span>
                            </div>
                            <div class="text">为啥我直接输入admin 123456 就登录进来了  哈哈
                            </div>
                            <div class="actions">


                            </div>
                        </div>

                    </div>
                    <div class="comment">
                        <a class="avatar">
                            <img src="img/photo.jpg">
                        </a>
                        <div class="content">
                            <a class="author">
                                <span>Dylan</span>

                            </a>
                            <div class="metadata">
                                <span class="date">2020-04-09 11:46</span>
                            </div>
                            <div class="text">真的厉害</div>
                            <div class="actions">


                            </div>
                        </div>

                    </div>
                    <div class="comment">
                        <a class="avatar">
                            <img src="img/photo.jpg">
                        </a>
                        <div class="content">
                            <a class="author">
                                <span>bm</span>

                            </a>
                            <div class="metadata">
                                <span class="date">2020-04-07 02:13</span>
                            </div>
                            <div class="text">不错不错</div>
                            <div class="actions">


                            </div>
                        </div>

                    </div>
                    <div class="comment">
                        <a class="avatar">
                            <img src="img/photo.jpg">
                        </a>
                        <div class="content">
                            <a class="author">
                                <span>123</span>

                            </a>
                            <div class="metadata">
                                <span class="date">2020-03-30 22:49</span>
                            </div>
                            <div class="text">做的太好了
                            </div>
                            <div class="actions">

                                <a class="viewReply" onclick="viewReply(this)" data-commentid="34" data-commentreplynums="1">查看回复(1)</a>
                            </div>
                        </div>
                        <div id="replyList" style="display: none;" class="comments">
                            <div class="comment">
                                <a class="avatar">
                                    <img src="img/photo.jpg">
                                </a>
                                <div class="content">
                                    <a class="author">
                                        <span>123</span>

                                        &nbsp;<span class="m-teal">@ 123</span>
                                    </a>
                                    <div class="metadata">
                                        <span class="date">2020-03-30 22:49</span>
                                    </div>
                                    <div class="text">123</div>
                                    <div class="actions">

                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <a class="avatar">
                            <img src="img/photo.jpg">
                        </a>
                        <div class="content">
                            <a class="author">
                                <span>Koueisen</span>

                            </a>
                            <div class="metadata">
                                <span class="date">2020-03-30 10:49</span>
                            </div>
                            <div class="text">点赞</div>
                            <div class="actions">


                            </div>
                        </div>

                    </div>
                </div>



                <div class="ui threaded comments" style="max-width: 100%;">
                    <h3 class="ui dividing header">评论</h3>

                </div>
            </div></div>
            <div id="comment-form" class="ui form">

                <div class="field">
                    <textarea name="content" placeholder="请输入评论信息..."></textarea>
                </div>
                <div class="fields">
                    <div class="m-margin-bottom-small m-mobile-wide  field">
                        <div class="ui m-margin-bottom-small m-mobile-wide left icon input">
                            <i class="user icon"></i>
                            <input type="text" name="name" placeholder="昵称" value="">
                        </div>
                    </div>

                    <div class=" m-margin-bottom-small m-mobile-wide  filed">
                        <button type="button" id="commentpost-btn" class="ui m-margin-bottom-small m-mobile-wide  teal button">
                            <i class="edit icon"></i>发布
                        </button>
                        <button type="button" id="clear-btn" class="ui m-margin-bottom-small m-mobile-wide grey button">
                            <i class="edit icon"></i>清除
                        </button>
                    </div>
                </div>
            </div>
        </div>

    </div>




</div>







</div>

<!-- 中间end -->






</body>
</html>
